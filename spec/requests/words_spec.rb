require 'rails_helper'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to test the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator. If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails. There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.

RSpec.describe "/words", type: :request do
  fixtures :users, :decks, :words, :deck_words
  # This should return the minimal set of attributes required to create a valid
  # Word. As you add validations to Word, be sure to
  # adjust the attributes here as well.
  let(:regular_user) { users(:test_user) }
  let(:superuser_account) { users(:superuser) }
  let(:deck) { decks(:basic_deck) }

  let(:valid_attributes) {
    {
      representation: "שלום",
      mnemonic: "Peace and greeting",
      pronunciation_url: "https://example.com/shalom.mp3",
      picture_url: "https://example.com/peace.jpg"
    }
  }

  let(:invalid_attributes) {
    {
      representation: ""  # Invalid because representation is required
    }
  }

  # Tests that work for both regular users and superusers
  shared_examples "accessible to all authenticated users" do
    describe "GET /index" do
      it "renders a successful response" do
        Word.create! valid_attributes
        get words_url
        expect(response).to be_successful
      end
    end

    describe "GET /show" do
      it "renders a successful response" do
        word = Word.create! valid_attributes
        get word_url(word)
        expect(response).to be_successful
      end
    end
  end

  context "as a regular user" do
    before { sign_in regular_user }

    include_examples "accessible to all authenticated users"
    it_behaves_like "paginatable", :words, Word, { representation: "שלום" }

    describe "GET /new" do
      it "redirects to root with authorization error" do
        get new_word_url
        expect(response).to redirect_to(root_path)
        expect(flash[:alert]).to eq("You are not authorized to perform this action.")
      end
    end

    describe "GET /edit" do
      it "redirects to root with authorization error" do
        word = Word.create! valid_attributes
        get edit_word_url(word)
        expect(response).to redirect_to(root_path)
        expect(flash[:alert]).to eq("You are not authorized to perform this action.")
      end
    end

    describe "POST /create" do
      it "redirects to root with authorization error" do
        expect {
          post words_url, params: { word: valid_attributes }
        }.to change(Word, :count).by(0)
        expect(response).to redirect_to(root_path)
        expect(flash[:alert]).to eq("You are not authorized to perform this action.")
      end
    end

    describe "PATCH /update" do
      it "redirects to root with authorization error" do
        word = Word.create! valid_attributes
        patch word_url(word), params: { word: { representation: "שמח" } }
        expect(response).to redirect_to(root_path)
        expect(flash[:alert]).to eq("You are not authorized to perform this action.")
      end
    end

    describe "DELETE /destroy" do
      it "redirects to root with authorization error" do
        word = Word.create! valid_attributes
        expect {
          delete word_url(word)
        }.to change(Word, :count).by(0)
        expect(response).to redirect_to(root_path)
        expect(flash[:alert]).to eq("You are not authorized to perform this action.")
      end
    end
  end

  context "as a superuser" do
    before { sign_in superuser_account }

    let(:verb_pos) { PartOfSpeechCategory.find_or_create_by!(name: 'Verb') { |pos| pos.abbrev = 'v' } }
    let(:noun_pos) { PartOfSpeechCategory.find_or_create_by!(name: 'Noun') { |pos| pos.abbrev = 'n' } }

    include_examples "accessible to all authenticated users"

    describe "GET /new" do
      it "renders a successful response" do
        get new_word_url
        expect(response).to be_successful
      end
    end

    describe "GET /edit" do
      it "renders a successful response" do
        word = Word.create! valid_attributes
        get edit_word_url(word)
        expect(response).to be_successful
      end
    end

    describe "POST /create" do
      context "with valid parameters" do
        it "creates a new Word" do
          expect {
            post words_url, params: { word: valid_attributes }
          }.to change(Word, :count).by(1)
        end

        it "redirects to the created word" do
          post words_url, params: { word: valid_attributes }
          expect(response).to redirect_to(word_url(Word.last))
        end
      end

      context "with invalid parameters" do
        it "does not create a new Word" do
          expect {
            post words_url, params: { word: invalid_attributes }
          }.to change(Word, :count).by(0)
        end

        it "renders a response with 422 status (i.e. to display the 'new' template)" do
          post words_url, params: { word: invalid_attributes }
          expect(response).to have_http_status(:unprocessable_content)
        end
      end
    end

    describe "PATCH /update" do
      context "with valid parameters" do
        let(:new_attributes) {
          { representation: "שמח" }
        }

        it "updates the requested word" do
          word = Word.create! valid_attributes
          patch word_url(word), params: { word: new_attributes }
          word.reload
          expect(word.representation).to eq("שמח")
        end

        it "redirects to the word" do
          word = Word.create! valid_attributes
          patch word_url(word), params: { word: new_attributes }
          word.reload
          expect(response).to redirect_to(word_url(word))
        end
      end

      context "with invalid parameters" do
        it "renders a response with 422 status (i.e. to display the 'edit' template)" do
          word = Word.create! valid_attributes
          patch word_url(word), params: { word: invalid_attributes }
          expect(response).to have_http_status(:unprocessable_content)
        end
      end
    end

    describe "DELETE /destroy" do
      it "destroys the requested word" do
        word = Word.create! valid_attributes
        expect {
          delete word_url(word)
        }.to change(Word, :count).by(-1)
      end

      it "redirects to the words list" do
        word = Word.create! valid_attributes
        delete word_url(word)
        expect(response).to redirect_to(words_url)
      end
    end

    describe "GET /show with forms and lexeme relationships" do
      it "displays linked forms on the parent word's page" do
        # Create a parent word (dictionary entry)
        parent = Word.create!(
          representation: 'לָמַד',
          part_of_speech_category: verb_pos,
          form_metadata: { conjugation: '3MS' }
        )
        parent.glosses.create!(text: 'he learned')

        # Create a form linked to the parent
        form = Word.create!(
          representation: 'לָמַדְתִּי',
          part_of_speech_category: verb_pos,
          lexeme_id: parent.id,
          form_metadata: { binyan: 'qal', aspect: 'perfective', conjugation: '1CS' }
        )
        form.glosses.create!(text: 'I learned')

        get word_url(parent)

        expect(response).to be_successful
        expect(response.body).to include('לָמַד')
        expect(response.body).to include('he learned')
        expect(response.body).to include('Related Forms')
        expect(response.body).to include('לָמַדְתִּי')
        expect(response.body).to include('qal perfective 1CS')
        expect(response.body).to include('I learned')
      end

      it "redirects from form to parent word with anchor" do
        # Create a parent word
        parent = Word.create!(
          representation: 'בֵּן',
          part_of_speech_category: noun_pos,
          form_metadata: { number: 'singular' }
        )

        # Create a form linked to the parent
        form = Word.create!(
          representation: 'בָּנִים',
          part_of_speech_category: noun_pos,
          lexeme_id: parent.id,
          form_metadata: { number: 'plural' }
        )

        get word_url(form)

        expect(response).to have_http_status(:moved_permanently)
        expect(response).to redirect_to(word_url(parent, anchor: "form-#{form.id}"))
      end

      it "does not show forms section for standalone words without forms" do
        word = Word.create!(
          representation: 'שָׁלוֹם',
          part_of_speech_category: noun_pos,
          form_metadata: { number: 'singular' }
        )

        get word_url(word)

        expect(response).to be_successful
        expect(response.body).to include('שָׁלוֹם')
        expect(response.body).not_to include('Related Forms')
      end

      it "groups verb forms separately from plural forms" do
        # Create a parent verb
        parent = Word.create!(
          representation: 'לָמַד',
          part_of_speech_category: verb_pos,
          form_metadata: { conjugation: '3MS' }
        )

        # Create verb conjugation
        verb_form = Word.create!(
          representation: 'לָמַדְתִּי',
          part_of_speech_category: verb_pos,
          lexeme_id: parent.id,
          form_metadata: { binyan: 'qal', aspect: 'perfective', conjugation: '1CS' }
        )

        get word_url(parent)

        expect(response).to be_successful
        expect(response.body).to include('Verb Conjugations')
        expect(response.body).to include('לָמַדְתִּי')
        expect(response.body).not_to include('Plural Forms')
      end

      it "displays plural forms in separate section" do
        # Create a parent noun
        parent = Word.create!(
          representation: 'בֵּן',
          part_of_speech_category: noun_pos,
          form_metadata: { number: 'singular' }
        )

        # Create plural form
        plural_form = Word.create!(
          representation: 'בָּנִים',
          part_of_speech_category: noun_pos,
          lexeme_id: parent.id,
          form_metadata: { number: 'plural' }
        )

        get word_url(parent)

        expect(response).to be_successful
        expect(response.body).to include('Plural Forms')
        expect(response.body).to include('בָּנִים')
        expect(response.body).not_to include('Verb Conjugations')
      end

      it "includes anchor IDs for each form" do
        parent = Word.create!(
          representation: 'בֵּן',
          part_of_speech_category: noun_pos,
          form_metadata: { number: 'singular' }
        )

        form = Word.create!(
          representation: 'בָּנִים',
          part_of_speech_category: noun_pos,
          lexeme_id: parent.id,
          form_metadata: { number: 'plural' }
        )

        get word_url(parent)

        expect(response).to be_successful
        expect(response.body).to include("id=\"form-#{form.id}\"")
      end
    end

    describe "POST /create with metadata" do
      it "creates a standalone word with metadata" do
        expect {
          post words_url, params: {
            word: {
              representation: "לָמַד",
              part_of_speech_category_id: verb_pos.id,
              conjugation: "3MS",
              binyan: "qal",
              aspect: "perfective"
            }
          }
        }.to change(Word, :count).by(1)

        word = Word.last
        expect(word.conjugation).to eq("3MS")
        expect(word.binyan).to eq("qal")
        expect(word.aspect).to eq("perfective")
        expect(word.lexeme_id).to be_nil
      end

      it "creates a linked word with lexeme_id and metadata" do
        parent = Word.create!(
          representation: 'לָמַד',
          part_of_speech_category: verb_pos,
          form_metadata: { conjugation: '3MS', binyan: 'qal' }
        )

        expect {
          post words_url, params: {
            word: {
              representation: "לָמַדְתִּי",
              part_of_speech_category_id: verb_pos.id,
              lexeme_id: parent.id,
              conjugation: "1CS",
              binyan: "qal",
              aspect: "perfective"
            }
          }
        }.to change(Word, :count).by(1)

        word = Word.last
        expect(word.lexeme_id).to eq(parent.id)
        expect(word.conjugation).to eq("1CS")
        expect(word.binyan).to eq("qal")
      end

      it "creates a noun with number and status metadata" do
        expect {
          post words_url, params: {
            word: {
              representation: "בֵּן",
              part_of_speech_category_id: noun_pos.id,
              number: "singular",
              status: "absolute"
            }
          }
        }.to change(Word, :count).by(1)

        word = Word.last
        expect(word.number).to eq("singular")
        expect(word.status).to eq("absolute")
      end
    end

    describe "PATCH /update with metadata" do
      it "updates metadata fields" do
        word = Word.create!(
          representation: "לָמַד",
          part_of_speech_category: verb_pos,
          form_metadata: { conjugation: '3MS' }
        )

        patch word_url(word), params: {
          word: {
            conjugation: "3MS",
            binyan: "qal",
            aspect: "perfective",
            root: "למד"
          }
        }

        word.reload
        expect(word.conjugation).to eq("3MS")
        expect(word.binyan).to eq("qal")
        expect(word.aspect).to eq("perfective")
        expect(word.root).to eq("למד")
      end

      it "can link a word to a parent" do
        parent = Word.create!(
          representation: 'בֵּן',
          part_of_speech_category: noun_pos,
          form_metadata: { number: 'singular' }
        )

        word = Word.create!(
          representation: 'בָּנִים',
          part_of_speech_category: noun_pos,
          form_metadata: { number: 'plural' }
        )

        patch word_url(word), params: {
          word: {
            lexeme_id: parent.id
          }
        }

        word.reload
        expect(word.lexeme_id).to eq(parent.id)
        expect(word.lexeme).to eq(parent)
      end
    end
  end
end
